import React, { useState, useEffect } from "react";
const resolveConfig = require("tailwindcss/resolveConfig");
const tailwindConfig = require("../../tailwind.config");

const fullConfig = resolveConfig(tailwindConfig);
const parseCssVariableName = (s) => s.match(/var\((.+)\)/)[1];
const PRIMARY_CSS_VARIABLES = Object.fromEntries(
  Object.entries(
    fullConfig.theme.colors.primary
  ).map(([shade, cssVariable]) => [shade, parseCssVariableName(cssVariable)])
);
const SECONDARY_CSS_VARIABLES = Object.fromEntries(
  Object.entries(
    fullConfig.theme.colors.secondary
  ).map(([shade, cssVariable]) => [shade, parseCssVariableName(cssVariable)])
);
// Swap primary and secondary properties in CSS
const invertThemeCss = () => {
  // Clear out any styles that were previously generated
  // document.documentElement.removeAttribute("style");
  Object.entries(PRIMARY_CSS_VARIABLES).map(([shade, primaryCssVariable]) => {
    const primaryColor = getComputedStyle(
      document.documentElement
    ).getPropertyValue(primaryCssVariable);
    const secondaryCssVariable = SECONDARY_CSS_VARIABLES[shade];
    const secondaryColor = getComputedStyle(
      document.documentElement
    ).getPropertyValue(secondaryCssVariable);
    document.documentElement.style.setProperty(
      primaryCssVariable,
      secondaryColor
    );
    document.documentElement.style.setProperty(
      secondaryCssVariable,
      primaryColor
    );
  });
};

// const getHex = (tailwindName) =>
//   _.get(fullConfig.theme.colors, tailwindName.replace("-", "."));

const THEMES = {
  whiteBlack: "theme-white-black",
  test1: "theme-test-1",
  test2: "theme-test-2",
};
const ThemeContext = React.createContext();
// eslint-disable-next-line react/prop-types
export const ThemeProvider = ({ children }) => {
  const [currentTheme, setCurrentTheme] = useState(THEMES.whiteBlack);
  const [isDarkMode, setIsDarkMode] = useState(false);
  useEffect(() => document.documentElement.classList.add(currentTheme), []);

  const changeTheme = (className) => {
    // Clear out any styles that were generated by invertTheme
    document.documentElement.removeAttribute("style");
    // remove any previous theme classnames
    document.documentElement.classList.remove(
      ...document.documentElement.classList
    );
    // Finally add the theme classname
    document.documentElement.classList.add(className);
    if (isDarkMode) {
      invertThemeCss();
    }
    setCurrentTheme(className);
  };
  const invertTheme = () => {
    invertThemeCss();
    setIsDarkMode((isDarkMode) => !isDarkMode);
  };

  return (
    <ThemeContext.Provider
      value={{
        invertTheme,
        changeTheme,
        isDarkMode,
        themes: THEMES,
        currentTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
};
export default ThemeContext;
